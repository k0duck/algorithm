## 문제

[구슬을 나누는 경우의 수](https://school.programmers.co.kr/learn/courses/30/lessons/120840)

## 풀이

### 실패 풀이

```java
public class Solution {

    static int balls;
    static int share;
    static boolean[] visited;
    static int cnt;

    public int solution(int balls, int share) {
        visited = new boolean[balls + 1];
        this.share = share;
        this.balls = balls;
        dfs(1);
        return cnt;
    }

    public void dfs(int ball) {
        if (ball == balls + 1) {
            String tmp = "";

            for (int i = 1; i <= balls; i++) {
                if (visited[i]) {
                    tmp += i;
                }
            }

            if (tmp.length() == share) {
                cnt++;
            }
        } else {
            visited[ball] = true;
            dfs(ball + 1);

            visited[ball] = false;
            dfs(ball + 1);
        }
    }
}
```

문제를 보고 가장 먼저 DFS(깊이 우선 탐색)로 접근했다.
구슬로 만들 수 있는 모든 경우의 수를 구한 뒤, 구슬의 개수가 `share`개일 때 `cnt`를 증가시켜 경우의 수를 구했다.<br>
하지만 이 풀이는 `share`개의 구슬을 고르는 경우의 수 이외에도 모든 경우의 수에 접근하는 방법이라 그런지 많은 테스트 케이스에서 `fail`과 `시간초과`가 떴다.
